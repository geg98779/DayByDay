## 学工程化时产生的疑问：有了 babel 为啥还需要 corejs?

1. Babel 的作用
Babel 的核心功能是 语法转换 (Syntax Transform)
比如：

// 源码 (ES6)
const fn = () => [1, 2, 3].includes(2);

// Babel 转换后的 ES5
var fn = function fn() {
  return [1, 2, 3].includes(2); // 注意：includes 没被改写！
};
👉 可以看到，Babel 只把 箭头函数 转换成了普通函数，但 Array.prototype.includes 这个新方法并没有处理。

为什么？
因为 Babel 主要解决的是“新语法 → 旧语法”，但 API/内置对象的功能 它不会自动模拟。

2. core-js 的作用
core-js 提供了 polyfill，也就是对新 API 的“补丁”。
比如：

Promise
Array.prototype.includes
Object.fromEntries
String.prototype.padStart
async/await 背后的 regenerator-runtime
如果你目标环境不支持这些 API，就需要 core-js 来“垫片”，让老环境也能运行。

import "core-js/stable";
import "regenerator-runtime/runtime";
这样 Babel 在编译时就能按需引入 polyfill。

3. 为什么不能只靠 Babel？
举个例子：假设你写了这样的代码

[1, 2, 3].includes(2);
只有 Babel：它不会改写 includes → 老浏览器（IE11）会直接报错 "Object doesn't support property or method 'includes'"。
Babel + core-js：会自动注入 polyfill，老浏览器也能正常运行。
4. 什么时候需要 core-js？
✅ 需要：

你要支持老浏览器（IE/旧版 Chrome/旧版 Safari）
你代码里用到了 ES6+ 的 API（Promise、includes、flat、Object.values 等）
❌ 不需要：

你的代码只跑在 Node.js 新版本（比如 Node 18+）
运行环境天然支持 ES6+ API（比如现代浏览器）
5. 总结一句
Babel：负责把新语法转成旧语法
core-js：负责补上旧环境缺少的 API
👉 没有 core-js，代码“看起来能编译”，但在老环境里会直接报错。