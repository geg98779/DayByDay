## component library solutions

### pnpm、npm、yarn
主要区别有两点：
1. pnpm支持全局共享存储，将依赖包安装到全局磁盘当中，使用的时候通过硬链接到达各个项目中去，允许不同项目共享相同的依赖，即使某一个依赖的版本不同，也只是去下载有diff的文件，不会全量下载。而npm和yarn在创建每个项目时，都会将所有项目的依赖放在当前目录下的node_modules,造成存储空间的浪费

2. pnpm解决了npm和yarn中存在幽灵依赖的问题
- 幽灵依赖指的是在软件项目中存在但并未在package.json中声明的依赖项
- 产生原因： 使用npm、yarn下载某些依赖时会下载上依赖的其他依赖项，但这些间接依赖项并未在json中显示声明
- 如何解决： 通过非扁平化的node_modules来解决的，也就是目录下只有.pnpm和直接依赖项，没有其他次级依赖包

### 那直接依赖项的依赖怎么办？同时怎么在下载的时候超过npm和yarn的速度呢？
pnpm的三层寻址机制：每个包的寻找都要经过三层结构：
每个项目 node_modules 下安装的包以软链接方式将内容指向node_modules/.pnpm中的包 .pnpm目录以扁平化结构管理每个版本包的源码内容，以硬链接方式指向pnpm-store中的文件地址

### 软链接和硬链接的不同

- 硬链接
1. 具有相同inode节点号的多个文件互为硬链接文件
2. 删除硬链接文件或者删除源文件任意之一，文件实体并未被删除
3. 只有删除了源文件和所有对应的硬链接文件，文件实体才会被删除
4. 硬链接文件是文件的另一个入口

- 软链接
1. 软链接类似windows系统的快捷方式
2. 软链接里面存放的是源文件的路径，指向源文件
3. 删除源文件，软链接依然存在，但无法访问源文件内容

### pnpm的hoist机制
即为依赖提升机制， 指将依赖包的某些文件或目录提升到项目的顶层node_modules目录中

### npm vs yarn
yarn的出现: 解决npm遗留的问题
1. 无法保证两次安装的版本是完全相同的
2. 安装速度慢
3. npm不支持离线模式，导致内网使用比较困难

yarn如何解决：
1. 引入.lock文件 保证每次安装都是一致的
2. 缓存加并行下载保证了安装速度

npm v5
引入了-lock文件 且自动添加 解决了版本问题
提高了安装速度 但依然没有yarn快
npm v6
加入了缓存 进一步提升了速度

yarn v2
增加PNP功能 .yarn目录代替node_modules
cache目录 存放所有需要的依赖的压缩包 zip格式
unplugged目录 存放需要手动修改的依赖
.pnp.js 存放元数据 所有的依赖定位功能都需要通过它
