## 按需加载
- 逻辑的按需引入
分别使用export导出每个组件,且使用esm形式导出,让构建工具可以进行tree shaking

- css
三种方案:
1. 样式和逻辑分离
打包后,js文件和css文件分离,需要手动引入css文件
- babel-plugin-import插件: 编译阶段辅助生成引入样式的import语句
优点: 不限制组件库,可以对外部直接提供less文件,便于组件库样式一键切换

缺点: 需要使用者手动引入css文件

2. 样式和逻辑结合
天然支持样式按需引入:
- css in js: 例如style-component 天然与逻辑文件绑定
- 将css打包到js中, webpack中通过style-loader将css代码打包进逻辑文件中
优点: 便于操作 天然支持 因为样式与逻辑在同一个文件中
缺点: 引用插件有额外的运行时,会略微影响组件库的性能

3. 样式和逻辑关联:
依旧使用import引入样式文件, 不过打包后生成独立的逻辑与样式文件, 但仍然会在逻辑文件中保留对应的import语句

缺点: 打包编译的流程会更加复杂,因为需要让逻辑文件通过import关联正确的css文件

## esm和cjs 模块化方案
1. 加载方式:
- 编译时加载: 通过export命令显式指定输出的代码 即可以指定加载某个值 而不是加载整个模块
- 运行时加载: commonjs模块就是对象,即在输入时先加载整个模块,生成一个对象, 然后从这个对象上面读取方法

2. 导入导出
esm支持异步导入,动态导入和命名导入等特性,可以根据需要动态导入导出,模块里面的变量绑定其所在的模块
commonjs只支持同步导入导出

3. 循环依赖处理方式
esm采用在编译阶段解决并处理 依赖地图 标记进入过的模块为获取中
cjs在第一次被require时就会执行并缓存对象,提供一个部分导出对象

4. 兼容性
esm只支持ES6的node或者浏览器
cjs兼容性更好

5. 输出
cjs输出的是一个值的浅拷贝 esm输出的是值的引用

## Vitest vs Jest
1. vitest原生支持ts,esm,而jest若要支持ts还需配置babel,通过babel转译来支持ts,而vitest这些特性都是开箱即用的

2. hmr比jest快

3. Jest 不支持浏览器ui测试,benchmark,ts类型测试


