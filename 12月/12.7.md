## 14 interview questions
1. 讲一下js闭包
- 产生原因
- 使用场景
- 使用坑点-内存泄露
- 如何解决
由于js采用的是词法作用域的方式来查找变量的，在js中，每个函数都会创建一个执行上下文EC，其中包含了函数内部的变量和局部作用域，正常来说，当一个函数执行完毕后，其执行上下文会被弹出执行上下文栈，此时外层函数的VO如果没有任何引用，会被垃圾回收器回收，但是，如果一个函数内部定义了一个新的函数，并且这个函数引用了外部函数的变量或参数，在这种特殊情况下，当外部函数执行并被销毁时，内部函数所引用的变量和参数并不会随之消失，形成了一个闭合的作用域，这就是闭包。一般利用它来创建私有变量，还有延长变量的生命周期，但同时也存在内存泄漏的风险，所以在开发时需要注意闭包是何时创建的以及保留了哪些对象

2. 柯里化的作用
柯里化是一种将接收多个参数的函数转换为一系列仅接收单个参数的函数的方法
核心是利用了闭包的特性 主要应用场景包括 参数复用 函数组合 延迟执行函数 还有定制化函数

3. forEach 和 Map 的区别
forEach没有返回值，在遍历的时候可以对原始数组的元素进行改动，而Map会将每个值映射为新的值，并返回一个新的数组作为返回结果 forEach侧重遍历操作 Map侧重对数据进行转换

4. 原型链
在js中 每个构造函数都有一个prototype属性 指向实例原型 构造函数的实例对象有一个__proto__属性 也指向实例原型
实例原型通过constructor反向指向构造函数, 属性查找时 会沿着__proto__向上不断查找，直到查找到原型链的尽头 Object.prototype.__proto__ 指向null，形成原型链

5. 深浅拷贝的地址
浅拷贝创建的只是新的顶层对象或数组的地址，但嵌套引用类型的地址是共享的，改动嵌套属性会影响原数据；深拷贝创建的是完全独立的新对象或数组，所有层级都有新地址

6. Json.stringify有什么弊端
无法处理循环引用 不支持特定的数据类型 丢失对象的原型链和方法 在处理大量对象或者深层嵌套对象的时候，可能会消耗大量的时间和内存

7. js数据类型
分为基本类型和引用类型 基本类型的数据存储在栈中 引用类型的数据存储在堆中 基本类型赋值 是生成相同的值 两个变量对应不同的内存地址 而引用类型赋值 是将对象的内存地址赋值给另一个变量

8. 怎么判断数据类型
typeof instanceof Object.prototype.tostring.call() constructor属性 Object.getPrototypeOf  Array.prototype.isPrototypeOf() Array.isArray()

9. 深拷贝是如何解决循环引用的
在深拷贝过程中 每次遇到一个对象需要拷贝时， 首先检查映射表中是否已经存在该对象的拷贝，如果存在，则直接返回拷贝副本， 避免重复拷贝， 如果不存在，则创建一个新的拷贝对象， 并将原对象和拷贝对象记录到映射表中（映射表通常泗使用weakmap，避免内存泄露）

10. this指向
在全局上下文中 如果宿主环境是浏览器 则为window对象 如果是node 则为global对象 在严格模式下 this为undefined
在函数上下文中 如果直接调用函数 this指向全局 方法调用 this指向调用方法的对象 构造函数调用 this指向新创建的对象实例
在剪头函数上下文中 箭头函数的this不同于普通函数的动态绑定，箭头函数为词法绑定，没有自己的this,绑定的是父级作用域的this,在声明时就确定了this，且无法改变

11. 暂时性死区的原因
由于js的变量提升机制和es6之后的词法环境的原因

12. 函数式思想
函数式思想是一种编程范式，核心是将计算过程拆解为一系列纯函数的组合，同时通过 “避免共享状态和可变数据、以及副作用的产生” 来提升代码的可预测性与可维护性，它的关键特性和应用主要有纯函数、高阶函数、函数组合、不可变性

13. 依赖注入
依赖注入是一种设计模式，它本质是控制反转（IoC）的一种实现方式，核心思路是把类与类之间的硬编码依赖关系剥离出来，不再让类自己创建依赖，而是通过构造函数参数、方法参数或者属性的方式来传递这些依赖，这样一来，依赖的创建和管理就被转移到了外部，由第三方统一控制。首先，这种方式能有效降低代码的耦合度，因为组件只需要关注依赖的接口，不用关心具体实现，自然就实现了组件间的解耦，让代码的可维护性和可复用性都得到了提升；然后，它的可测试性会更强，在单元测试的时候，我们可以很方便地注入模拟的依赖对象，把被测代码和实际依赖隔离开，保证测试的独立性和可靠性；同时，这也让代码的可维护性变得更高，因为组件之间没有了直接的依赖关系，后续如果需要修改或者更新某个依赖，只需要在管理依赖的地方做调整，不会影响到其他代码；另外，通过构造方法注入的方式还能保障依赖的不可变性，因为构造方法在对象创建时只会执行一次，且注入的对象不会被随意修改，进一步提高了代码的稳定性。

14. 用过哪些设计模式
发布订阅模式，它是一种消息范式，发布者不会将消息直接发送给订阅者，而是将发布的消息分为不同的类别，无需了解哪些订阅者存在，同样，订阅者也只订阅感兴趣的消息，只接受感兴趣的消息，无需了解哪些发布者存在
观察者模式：定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于他的对象都将得到通知，并自动更新。
**区别：** 观察者模式中，观察者是知道subject的，subject一直保持对观察者进行记录，然而，在发布订阅模式中，发布者和订阅者都不知道对方的存在，它们只有通过消息代理进行通信,前者组件是紧耦合的，后者是松耦合的，前者大多数时候是同步的，而后者大多数时候是使用的消息队列，是异步的
策略模式： 利用组合、委托等技术和思想，有效的避免很多if条件语句，提供开放-封闭原则，使代码更容易理解和扩展，策略模式中的代码可以复用
