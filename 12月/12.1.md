## promiseAllLimit
```js
function promiseAllLimit(limit) {
            return function (promiseFactories) {
                let results = []
                let running = 0
                let completed = 0
                let index = 0

                return new Promise((resolve, reject) => {
                    while (running < limit && index < promiseFactories.length) {
                        nextPromise()
                    }

                    function nextPromise() {
                        if (completed >= promiseFactories.length) {
                            resolve(results)
                            return
                        }

                        if (index >= promiseFactories.length) {
                            return
                        }

                        let currentIndex = index
                        let promiseFactory = promiseFactories[currentIndex]
                        index++

                        promiseFactory().then(result => {
                            results[currentIndex] = result
                            completed++
                            running--
                            if (completed >= promiseFactories.length) {
                                resolve(results)
                            } else {
                                nextPromise()
                            }
                        }).catch(error => {
                            reject(error)
                        })

                        running++
                    }
                })
            }
        }
```

## 超时中断封装
```js
function withTimeout(promise, timeout) {
            const controller = new AbortController()
            const signal = controller.signal

            const timeoutId = setTimeout(() => {
                controller.abort()
            }, timeout)

            return Promise.race([
                promise, new Promise((resolve, reject) => {
                    signal.addEventListener('abort', () => {
                        clearTimeout(timeoutId)
                        reject(new Error("Timeout"))
                    })
                })
            ])
        }
```

## hot100 寻找两个正序数组的中位数
```js
function findMedianSortedArrays(a, b) {
    if (a.length > b.length) {
        [a, b] = [b, a]
    }
    const m = a.length
    const n = b.length
    let left = -1
    let right = m

    while (left + 1 < right) {
        const i = Math.floor((left + right) / 2)
        const j = Math.floor((m + n - 3) / 2) - i
        if (a[i] <= b[j + 1]) {
            left = i
        } else {
            right = i
        }
    }

    const i = left
    const j = Math.floor((m + n - 3) / 2) - i
    const ai = i >= 0 ? a[i] : -Infinity
    const bj = j >= 0 ? b[j] : -Infinity
    const ai1 = i + 1 < m ? a[i + 1] : Infinity
    const bj1 = j + 1 < n ? b[j + 1] : Infinity
    const max1 = Math.max(ai, bj)
    const max2 = Math.min(ai1, bj1)
    return (m + n) % 2 ? max1 : (max1 + max2) / 2
}
```
## 长列表渲染问题解决方案
- 无限加载
怎么判断用户是否滑到底部
1. intersectionObserver
设定一个哨兵元素 使用实例的observe方法监听
实例可以传入一个回调和配置项 配置root rootmargin 提前触发加载 做到无感下滑
2. 监听scrollTop + 容器高度
滚动高度加元素可视高度大于元素内容高度 加载
因为监听了滚动事件 避免频繁触发 所以需要节流处理

- 虚拟列表
只渲染可视窗口内的元素而其余元素不渲染 从而极大程度减少了dom数量 提升渲染性能

1. listItem定高
两个核心进行计算:
- 当前滚动位置
- 列表项的高度

2. listItem不定高
对于某些商品长列表，图片稍微大点或者介绍信息长就会形成这种不定高的列表项

难点：
- 外部容器总长不确定
- 无法通过scrolltop/itemHeight获取初始索引值
