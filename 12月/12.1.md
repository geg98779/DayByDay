## promiseAllLimit
```js
function promiseAllLimit(limit) {
            return function (promiseFactories) {
                let results = []
                let running = 0
                let completed = 0
                let index = 0

                return new Promise((resolve, reject) => {
                    while (running < limit && index < promiseFactories.length) {
                        nextPromise()
                    }

                    function nextPromise() {
                        if (completed >= promiseFactories.length) {
                            resolve(results)
                            return
                        }

                        if (index >= promiseFactories.length) {
                            return
                        }

                        let currentIndex = index
                        let promiseFactory = promiseFactories[currentIndex]
                        index++

                        promiseFactory().then(result => {
                            results[currentIndex] = result
                            completed++
                            running--
                            if (completed >= promiseFactories.length) {
                                resolve(results)
                            } else {
                                nextPromise()
                            }
                        }).catch(error => {
                            reject(error)
                        })

                        running++
                    }
                })
            }
        }
```

## 超时中断封装
```js
function withTimeout(promise, timeout) {
            const controller = new AbortController()
            const signal = controller.signal

            const timeoutId = setTimeout(() => {
                controller.abort()
            }, timeout)

            return Promise.race([
                promise, new Promise((resolve, reject) => {
                    signal.addEventListener('abort', () => {
                        clearTimeout(timeoutId)
                        reject(new Error("Timeout"))
                    })
                })
            ])
        }
```

## hot100 寻找两个正序数组的中位数
```js
function findMedianSortedArrays(a, b) {
    if (a.length > b.length) {
        [a, b] = [b, a]
    }
    const m = a.length
    const n = b.length
    let left = -1
    let right = m

    while (left + 1 < right) {
        const i = Math.floor((left + right) / 2)
        const j = Math.floor((m + n - 3) / 2) - i
        if (a[i] <= b[j + 1]) {
            left = i
        } else {
            right = i
        }
    }

    const i = left
    const j = Math.floor((m + n - 3) / 2) - i
    const ai = i >= 0 ? a[i] : -Infinity
    const bj = j >= 0 ? b[j] : -Infinity
    const ai1 = i + 1 < m ? a[i + 1] : Infinity
    const bj1 = j + 1 < n ? b[j + 1] : Infinity
    const max1 = Math.max(ai, bj)
    const max2 = Math.min(ai1, bj1)
    return (m + n) % 2 ? max1 : (max1 + max2) / 2
}
```
