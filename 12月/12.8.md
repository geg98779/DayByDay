## 12 interview questions
1. 讲一下js闭包
- 产生原因
- 使用场景
- 使用坑点-内存泄露
- 如何解决
由于js采用的是词法作用域的方式来查找变量的，在js中，每个函数都会创建一个执行上下文EC，其中包含了函数内部的变量和局部作用域，正常来说，当一个函数执行完毕后，其执行上下文会被弹出执行上下文栈，此时外层函数的VO如果没有任何引用，会被垃圾回收器回收，但是，如果一个函数内部定义了一个新的函数，并且这个函数引用了外部函数的变量或参数，在这种特殊情况下，当外部函数执行并被销毁时，内部函数所引用的变量和参数并不会随之消失，形成了一个闭合的作用域，这就是闭包。一般利用它来创建私有变量，还有延长变量的生命周期，但同时也存在内存泄漏的风险，所以在开发时需要注意闭包是何时创建的以及保留了哪些对象

1. 柯里化的作用
柯里化是一种将接收多个参数的函数转换为一系列仅接收单个参数的函数的方法
核心是利用了闭包的特性 主要应用场景包括 参数复用 函数组合 延迟执行函数 还有定制化函数

1. forEach 和 Map 的区别
forEach没有返回值，在遍历的时候可以对原始数组的元素进行改动，而Map会将每个值映射为新的值，并返回一个新的数组作为返回结果 forEach侧重遍历操作 Map侧重对数据进行转换

1. 原型链
在js中 每个构造函数都有一个prototype属性 指向实例原型 构造函数的实例对象有一个__proto__属性 也指向实例原型
实例原型通过constructor反向指向构造函数, 属性查找时 会沿着__proto__向上不断查找，直到查找到原型链的尽头 Object.prototype.proto 指向null，形成原型链

1. 深浅拷贝的地址
浅拷贝创建的只是新的顶层对象或数组的地址，但嵌套引用类型的地址是共享的，改动嵌套属性会影响原数据；深拷贝创建的是完全独立的新对象或数组，所有层级都有新地址

1. Json.stringify有什么弊端
无法处理循环引用 不支持特定的数据类型 丢失对象的原型链和方法 在处理大量对象或者深层嵌套对象的时候，可能会消耗大量的时间和内存

1. js数据类型
分为基本类型和引用类型 基本类型的数据存储在栈中 引用类型的数据存储在堆中 基本类型赋值 是生成相同的值 两个变量对应不同的内存地址 而引用类型赋值 是将对象的内存地址赋值给另一个变量

1. 怎么判断数据类型
typeof instanceof Object.prototype.tostring.call() constructor属性 Object.getPrototypeOf  Array.prototype.isPrototypeOf() Array.isArray()

1. 深拷贝是如何解决循环引用的
在深拷贝过程中 每次遇到一个对象需要拷贝时， 首先检查映射表中是否已经存在该对象的拷贝，如果存在，则直接返回拷贝副本， 避免重复拷贝， 如果不存在，则创建一个新的拷贝对象， 并将原对象和拷贝对象记录到映射表中（映射表通常泗使用weakmap，避免内存泄露）

1.  this指向
在全局上下文中 如果宿主环境是浏览器 则为window对象 如果是node 则为global对象 在严格模式下 this为undefined
在函数上下文中 如果直接调用函数 this指向全局 方法调用 this指向调用方法的对象 构造函数调用 this指向新创建的对象实例
在剪头函数上下文中 箭头函数的this不同于普通函数的动态绑定，箭头函数为词法绑定，没有自己的this,绑定的是父级作用域的this,在声明时就确定了this，且无法改变

1.  暂时性死区的原因
由于js的变量提升机制和es6之后的词法环境的原因

1.  函数式思想
函数式思想是一种编程范式，核心是将计算过程拆解为一系列纯函数的组合，同时通过 “避免共享状态和可变数据、以及副作用的产生” 来提升代码的可预测性与可维护性，它的关键特性和应用主要有纯函数、高阶函数、函数组合、不可变性
