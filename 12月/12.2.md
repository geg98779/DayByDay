## Sort Algorithm
```js
function quickSort(arr){
            if(arr.length <= 1) return arr
            const pivotIndex = Math.floor(arr.length / 2)
            const pivot = arr[pivotIndex]
            const less = []
            const greater = []

            for(let i= 0; i < arr.length; i++){
                if(i === pivotIndex){
                    continue
                }

                if(arr[i] <= pivot) {
                    less.push(arr[i])
                }else{
                    greater.push(arr[i])
                }
            }
            return [...quickSort(less),pivot, ...quickSort(greater)]
        }
```

```js
function twoSplit = (n, target) => {
    let left = 0
    let right = nums.length - 1
    let middle = Math.floor((left + right) / 2)

    while(left <= right){
        if(nums[middle] > target){
            right = middle - 1
            middle = Math.floor((right + left) / 2)
        }else if(nums[middle]  < target){
            left = middle + 1
            middle = Math.floor((right + left) / 2)
        }else if(nums[middle] === target){
            return middle
        }
    }
    return left
}
```

```js
function mergeSort(arr){
    if(arr.length <= 1){
        return arr
    }

    const middle = Math.floor(arr.length / 2)
    const left = arr.slice(0,middle)
    const right = arr.slice(middle)
    return merge(mergeSort(left), mergeSort(right))
}

function merge(left,right){
    let result = []
    let leftIndex = 0
    let rightIndex = 0
    while(leftIndex < left.length && rightIndex < right.length){
        if(left[leftIndex] < right[rightIndex]){
            result.push(left[leftIndex])
            leftIndex++
        }else{
            result.push(right[rightIndex])
            rightIndex++
        }
    }
    return result.concat(left.slice(leftIndex)).concat(right.slice(rightIndex))
}
```

## 长列表渲染问题解决方案
- 无限加载
怎么判断用户是否滑到底部
1. intersectionObserver
设定一个哨兵元素 使用实例的observe方法监听
实例可以传入一个回调和配置项 配置root rootmargin 提前触发加载 做到无感下滑
2. 监听scrollTop + 容器高度
滚动高度加元素可视高度大于元素内容高度 加载
因为监听了滚动事件 避免频繁触发 所以需要节流处理

- 虚拟列表
只渲染可视窗口内的元素而其余元素不渲染 从而极大程度减少了dom数量 提升渲染性能

1. listItem定高
两个核心进行计算:
- 当前滚动位置
- 列表项的高度
**面试参考答案：** 该组件首先通过 useState 维护滚动距离 scrollTop，绑定 onScroll 事件监听滚动并更新 scrollTop 触发重渲染；接着计算总数据量、可视区 + 缓冲项数量，结合 scrollTop 算出可视区起始 / 结束索引，切取仅需渲染的可视区数据；然后构建三层 DOM 结构，外层为固定高度的滚动容器，中间占位容器通过总项数 × 单项高度模拟列表总高度保证滚动条正常，内层偏移容器通过 startIndex× 单项高度的 paddingTop 让可视区数据对齐滚动位置；最后遍历可视区数据，用 startIndex + 局部索引作为唯一 key，调用 renderItem 自定义渲染每项内容，同时通过 Math.min 处理索引越界、buffer 缓冲项优化滚动体验，实现定高虚拟列表的按需渲染。

2. listItem不定高
对于某些商品长列表，图片稍微大点或者介绍信息长就会形成这种不定高的列表项
**面试参考答案：** 不定高虚拟列表的实现逻辑会在定高基础上做调整，核心是先解决 “每项高度不固定” 的核心问题：首先得通过「预计算」（比如根据内容估算高度）或「动态测量」（渲染后用 DOM API 获取实际高度），拿到每一项的真实高度，再基于这些高度构建「位置映射表」（存储每一项的起始位置和累计高度）；接着滚动时，通过映射表反向计算当前滚动距离对应的可视区起始 / 结束索引（比如用二分法快速定位，避免遍历所有项）；DOM 结构上，占位容器高度改为 “所有项实际高度的总和”，偏移容器用transform: translateY（更灵活适配动态高度）替代固定paddingTop，确保可视区内容对齐；同时要额外处理「尺寸变化」场景 —— 比如列表项内容更新导致高度变了，需要重新测量并更新位置映射表，避免滚动错位；性能上，用useMemo缓存映射表减少重计算，对尺寸监听做节流，缓冲项数量也建议适当增加（比如 8~12 项），应对高度波动导致的滚动闪白；整体难点在于高度测量的精准性和位置计算的性能，既要保证滚动体验和定高一致，又要适配高度动态变化的特性。
难点：
- 外部容器总长不确定
- 无法通过scrolltop/itemHeight获取初始索引值
