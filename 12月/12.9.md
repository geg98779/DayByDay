## 12 interview questions
1. 内存泄露的原因，怎么解决内存泄露
内存泄漏的主要原因有闭包，无法避免，需要了解闭包是如何创建的以及它保留了哪些对象，未处理监听事件和定时器，dom元素未正确移除，循环引用，

2. bind第一次调用返回什么
返回一个新的函数， 该函数已经绑定了一个指定的上下文和参数

3. 循环引用相关问题
解决问题的关键是不进行死循环，对于模块循环引用的话， 在commonjs中，每个模块都先加入缓存再执行，esmodule中，使用一张模块间的依赖地图，标记进入过的模块为“获取中”，所以循环引用时不会再次进入，对于对象循环引用，会造成json数据的序列化错误，对象的深拷贝无法正确处理循环引用，json序列化错误可以通过cycle.js中的json.decycle解决，通过weakmap来记录每一个对象来解决深拷贝的循环引用问题

4. promise的api
promise.all 返回值是一个新的promise实例，all接收一个可遍历的数据容器，数组中全部由pending转为fulfilled状态时才会成功，但只要出现一个reject，all就会失败，all的catch会捕获到这个reject

promise.race 接收一个promise数组，当接收的promise中第一个promise实例被解决或拒绝时，返回的promise就会被解决或拒绝

promise.allSettled 接收一个promise数组，无论异步操作成功与否，都需要等待其完成才可以继续执行下一步操作

promise.any 接收一个promise数组，只要有一个promise实例成功就成功，所有promise失败时，any返回的promise才失败

promise.finally 在promise结束时，无论是resolve还是reject，都需要执行finally里面的回调函数

5. promise异常穿透
指发生异常但没有被catch到，异常就会传递到下一个promise链中的错误处理方法，如果异常一直传递到promise链的结尾却仍然没有被处理，就会触发全局的unhandledrejection事件

6. async await
它们是生成器函数的语法糖，其中async对应生成器的函数声明，await对应yield的暂停逻辑；
但它内置了自动执行器，不需要像生成器那样手动调用next()，会自动处理异步操作的完成与流程推进；最终实现 “用同步代码写异步逻辑” 的效果

7. 性能优化
- 网络优化：
  1. 连接优化：连接建立分为dns查询和tcp连接两个步骤 DNS查询通过DNS Prefetch 和 preconnect 来进行优化，preconnect比dns-prefetch做的更多，他会提前建立tcp连接，能减少更多的时间
  2. 开启http2: http2将http协议通信分解为二进制编码帧的交换，这些帧对应着特定数据流中的消息。所有这些都在一个tcp连接内复用。多路复用：将http消息分解为独立的帧，交错发送，然后在另一端重新组装，这个机制会在整个网络技术栈中引发一系列连锁反应，从而带来巨大的性能提升，还有其他新特性比如服务端推送，头部压缩，http2的升级省了很多事，比如雪碧图、文件合并、内容内嵌、域名分片
- 针对html&css&js等资源加载耗时
  1. html： 主要方向为减少html体积和减少html白屏，对于体积的话，响应头中压缩方式使用gzip或者br，另一个就是减少标签嵌套。对于白屏的话，可以采用骨架屏，在真实数据返回之前先展示骨架屏提升用户体验，还有就是SSG，对于某些界面来说，界面内容不是经常变动，对于这些静态内容，是可以提前渲染的，直接注入到html里面，
  2. css： 主要方向为体积优化、chunk拆分、预加载，对于体积，冗余内容可以使用postcss的cssnano插件来实现，无用的css样式和已删除标签的样式可以借助purgecss工具来实现。对于chunk拆分，分为公共资源和首屏资源，可以借助webpack提供的splitChunks来实现公共资源的拆分，首屏资源的话，由于css加载会阻塞界面渲染，所以header中放的css最好都是首屏需要的，对于首屏不需要的css文件可以先放到首屏代码的后面在引入。对于预加载，给link文件添加preload属性，提前加载首屏css
  3. js： 主要方向为减少体积，使用webpack的splitChunks进行代码拆分，使用compression-webpack-plugin中的gzip算法减小资源体积，tree-shaking，对于公共资源，可以不打包进产物中，直接使用cdn进行引用
- 图片
  1. 图片压缩： 最好上传的时候进行压缩，压缩后如果可以选择webp格式的图片更好
  2. 加载体验： 可以从图片尺寸 避免、图片格式、懒加载、占位、渐进式加载的方向入手。
- dom解析优化
  1. 非首屏内容后置 即js后置 如果是ssr的界面，就不会阻塞首屏内容渲染
  2. 异步加载： async或者defer
- FCP
    通过浏览器devtool中的Performance直接得到具体加载数据，和通用优化方案相差无二，可以通过添加骨架屏的形式，提前提供可供感知的内容，改善fcp的体验
- FMP
    无法通过Performance获取到具体时间，因为针对的页面不同，其页面的主要内容也不同，通常有两种方式确定FMP的时间，第一种是通过页面最大有意义元素算法，第二种是通过人为确定，在规定的最大有意义元素出现之时上报埋点统计时间就行。对于一个常规的非移动端 CSR 来说，首屏前的主要流程为:加载 HTML、CSS、JS 等资源文件 -->代码运行至 mount 阶段发起 API接口请求 -->等待收到数据后渲染首屏，针对第二点(代码运行至 mount 阶段发起 API接口请求)与第三点(等待收到数据后渲染首屏)分别进行优化：
    1. 对于第二点： 可以让接口请求/响应时机提前，在根组件函数外发起请求，并将接口返回的数据存储到store中，还可以对接口耗时进行优化，
