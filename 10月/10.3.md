## hand-slice js
- 对字符串进行排序并去重
```js
const str = "fsdjkfkldsfj"
const sortAndUnique = (str) => {
    let newArr = str.split("").sort()
    let map = new Map()
    let length = newArr.length
    for(let i = 0; i < length; i++){
        if(map.has(newArr[i])){
            newArr.splice(i,1)
        }else{
            map.set(newArr[i],newArr[i])
        }
    }
    return newArr.join('')
}
```

- 前序遍历
```js
const frontTree = (root) =>{
    const recur = (root,result) =>{
        if(root === null) return null
        result.push(root.value)
        recur(root.left, result)
        recur(root.right, result)
    }
    let result = []
    recur(root, result)
    return result
}
```

- 如何给一个在闭包里的对象添加新的属性
```js
//通过在闭包内部暴露公开的函数的和方法来添加新的属性
function createClosure() {
    let obj = {}
    function setNewProperty(key, value){
        obj[key] = value
    }

    function getObj(){
        return obj
    }
    return {
        setNewProperty: setNewProperty,
        getObj: getObj
    }
}
```

- cookie怎么获取指定key的内容
```js
function getCookieValue(key){
    let cookies = document.cookie.split("; ")

    for(let i = 0; i < cookies.length; i++){
        let cookie = cookies[i].split("=")
        let cookiekey = decodeURIComponent(cookie[0])

        let cookieValue = decodeURIComponent(cookie[1])

        if(cookieKey === key) return cookieValue
    }
    return null
}
```

- 实现一个usePrevious获取上一个state的值
```js
const usePrevious = (value) => {
    const ref = useRef()

    useEffect(() => {
        ref.current = value
    }, [value])

    return ref.current
}
```

- 防抖
```js
const debounce = (fn, delay) => {
    let timer = null
    return (args) => {
        clearTimeOut(timer)
        const timer = setTimeOut(() => {
            fn.call(this,args)
        },delay)
    }
}
```

- 节流
```js
const throttle = (fn,delay) => {
    let timer = null
    return (args) =>{
        if(!timer) {
            timer = setTimeout(() => {
                fn.call(this,args)
                timer = null
            },delay)
        }
    }
}
```

- call bind
```js
Function.prototype.call = (context, ...args) => {
    let cur = this
    let signal = Symbol("call")
    context[signal] = cur
    let result = context[signal](...args)
    delete context[signal]
    return result
}

Function.prototype.bind = function (context,...args){
    let cur = this
    return function(...params) {
        let newArg = [...args,...params]
        let signal = Symbol("bind")
        context[signal] = cur
        let result = context[signal](...newArg)
        delete context[signal]
        return result
    }
}
```

- 柯里化
```js
const curry = (fn,length = fn.length) => {
    return curry_.call(this, fn, length)
}
const curry_ = (fn, length, ...args) => {
    return function(...params) {
        let arg = [...args, ...params]
        if(arg.length > length){
            fn.call(this, ...arg)
        }else{
            curry_.apply(this, fn, length, arg)
        }
    }
}
```