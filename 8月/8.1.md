## Blender是什么？
Blender 是一款免费开源的 3D 创作套件。它支持 3D 创作的整个流程，包括建模、绑定、动画、模拟、渲染、合成、运动跟踪，甚至视频编辑和游戏资产创建等。以下是对 Blender 的详细介绍：

功能特点：
渲染：Blender 内置的 Cycles 渲染器是一款高端的路径追踪渲染器，能够创建出令人惊叹的渲染效果，支持 CPU 和 GPU 渲染、PBR 材质和 HDR 照明，还支持 VR 渲染。
建模：拥有丰富的建模工具集，包括雕刻、拓扑重建、曲线建模等功能。它全面支持 N 边形，具备边滑动、插入、网格填充和桥接等操作，方便用户创建复杂的模型。
动画与绑定：Blender 的动画和绑定功能强大，被广泛用于制作获奖短片和故事片。它支持信封绑定、骨骼绑定和自动蒙皮，提供 B 样条插值骨骼、曲线编辑器和摄影表等工具，还能实现声音同步。
视觉特效（VFX）：从相机和物体运动跟踪到遮罩和合成，Blender 提供了一系列专业的 VFX 工具。它被认为是市场上最好的跟踪器之一，支持自动和手动跟踪、强大的相机重建以及实时预览跟踪素材和 3D 场景。
模拟：Blender 提供了强大的模拟工具，集成了 Bullet 和 MantaFlow 等行业标准库，可以精确模拟烟雾、火焰、布料等自然现象。
视频编辑：Blender 的视频编辑器提供了一系列基本但非常高效的工具，可用于设置转场、添加标题文字、音频和简单的调色等操作。
跨平台特性：Blender 是跨平台的应用工具，可在 Linux、macOS 以及 Windows 系统下运行。其界面使用 OpenGL，在所有支持的硬件与平台都能提供一致的用户体验。
可扩展性：Blender 具有广泛的 Python API，用户可以通过编写 Python 脚本来定制应用程序和编写专用工具，还可以开发和分享自己的插件，以增强软件的功能。
社区支持：Blender 有一个活跃的社区，社区中包含了大量的教程制作者、内容创作者、插件开发者和全球市场，为用户提供了丰富的学习资源和拓展途径。

## truthy（真值）和 true 
在 JavaScript 中，truthy（真值）和 true 是两个相关但不同的概念。true 是布尔类型的字面量（仅一个值），而 truthy 是一个更宽泛的概念 —— 指 “在布尔上下文（如条件判断）中会被转换为 true 的值”。
核心区别：
true 是具体的布尔值，仅 true 本身。
truthy 是一类值的统称，包括 true 在内，以及其他在条件判断中被视为 “真” 的值（如非空字符串、非零数字等）。
1. 仅以下 6 个值是 falsy（假值）：
false（布尔假）
0 和 -0（数字零）
"" 或 ''（空字符串）
null
undefined
NaN（非数字）
2. 其余所有值都是 truthy，例如：
true（布尔真）
非零数字：1、-1、3.14
非空字符串："hello"、" "（含空格的字符串）
对象：{}、[]（空对象 / 数组也是真值）
函数：function() {}

##  .passive事件修饰符
.passive 是 Vue 事件修饰符之一，主要用于优化触摸和滚动事件的性能，解决移动端常见的 “滚动卡顿” 问题。它的核心作用是告诉浏览器：“这个事件处理函数不会调用 preventDefault() 阻止默认行为”，让浏览器可以放心地优化滚动或触摸操作。是专门针对 touchmove、scroll 等事件的性能优化修饰符，通过告诉浏览器 “不阻止默认行为”，避免滚动卡顿，让移动端滑动更流畅。记住：在处理触摸或滚动事件时，加上 .passive 通常是更好的选择（除非你确实需要用 preventDefault() 阻止默认行为）。

## 灰度测试
灰度测试，又名灰度发布、金丝雀发布，是在某项产品或应用正式发布前，选择特定人群试用，逐步扩大其试用者数量，以便及时发现和纠正其中问题的一种测试方式

## 用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击 为啥？
假设有嵌套结构，父元素用了 .prevent.self，子元素没有任何修饰符：
```js
<!-- 父元素：.prevent.self -->
<div class="parent" @click.prevent.self="log('父元素')">
  <!-- 子元素：无修饰符 -->
  <button class="child" @click="log('子元素')">点击</button>
</div>
```
### 点击子元素的完整流程（关键！）
子元素触发点击：
点击按钮（子元素）时，首先触发子元素的 click 事件，执行子元素的处理函数（log('子元素')）。
此时，子元素的默认行为（如按钮的点击反馈）还未执行。
事件开始冒泡：
子元素的点击事件会向上传播（冒泡）到父元素。
父元素的修饰符生效：
父元素的 .prevent 先执行（修饰符从左到右执行），作用于这个 “从子元素冒泡上来的事件”，调用 e.preventDefault()。
✅ 重点：e.preventDefault() 一旦执行，会阻止整个事件链中所有未执行的默认行为，包括子元素本身的默认行为（因为事件还在传播中，子元素的默认行为还没来得及执行）。
父元素的 .self 检查：
接着执行 .self，发现这个事件是从子元素冒泡来的（不是父元素自身被点击），所以父元素的处理函数（log('父元素')）不执行。
### 为什么子元素的默认行为会被阻止？
子元素的默认行为（如按钮点击的视觉反馈）是在事件传播到目标元素后才执行的，但事件冒泡时，父元素的 .prevent 先一步调用了 e.preventDefault()，这个方法会 “全局” 阻止当前事件链中所有未发生的默认行为。
简单说：事件是同一个，父元素在事件冒泡过程中阻止了它的默认行为，自然就包括子元素还没执行的默认行为。
### 对比：.self.prevent 为什么不会影响子元素？
如果父元素用 .self.prevent，流程变为：
子元素点击后，事件冒泡到父元素。
先执行 .self：检查发现事件来自子元素，直接跳过后续处理（包括 .prevent）。
因此，e.preventDefault() 从未执行，子元素的默认行为能正常触发。
### 理解完后的自我输出(通俗易懂讲人话) 
也就是说父元素有prevent修饰符 点击父元素 所有子元素也都会取消默认事件 再点击子元素 在当前生命周期下 永远不会触发默认事件 并且事件冒泡的执行时间在默认事件触发之前 这里是关键 正是因为这个既定的顺序 从而导致了父元素可以阻止子元素的默认事件

