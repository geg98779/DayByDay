## 浅拷贝的本质
浅拷贝意味着，新的数组中的元素，和原数组中的元素，引用的是同一个对象```
举个例子
```js
const originalArray = [{ id: 1 }, { id: 2 }];
const newArray = originalArray.slice();

// newArray 是一个新的数组，内存地址和 originalArray 不同
console.log(newArray === originalArray); // false

// 但是，新数组中的对象元素，和原数组中的对象元素，是同一个
console.log(newArray[0] === originalArray[0]); // true
```
虽然 newArray 中的 [0] 元素和 originalArray 中的 [0] 元素指向的是同一个对象，但是 newArray 本身作为一个数组容器，是一个全新的对象，它需要自己的内存空间来存储对这些元素的引用。
！！！ 所以还是会提高空间复杂度，降低性能

## LCA
当一个节点 p 是另一个节点 q 的祖先时，LCA(p, q) 永远是 p 本身。反之亦然，如果 q 是 p 的祖先，那么 LCA(p, q) 就是 q。这是因为 p 和 q 的所有公共祖先中，p 是离它们最近且深度最大的。