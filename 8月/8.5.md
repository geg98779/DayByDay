## 浅拷贝的本质
浅拷贝意味着，新的数组中的元素，和原数组中的元素，引用的是同一个对象```
举个例子
```js
const originalArray = [{ id: 1 }, { id: 2 }];
const newArray = originalArray.slice();

// newArray 是一个新的数组，内存地址和 originalArray 不同
console.log(newArray === originalArray); // false

// 但是，新数组中的对象元素，和原数组中的对象元素，是同一个
console.log(newArray[0] === originalArray[0]); // true
```
虽然 newArray 中的 [0] 元素和 originalArray 中的 [0] 元素指向的是同一个对象，但是 newArray 本身作为一个数组容器，是一个全新的对象，它需要自己的内存空间来存储对这些元素的引用。
！！！ 所以还是会提高空间复杂度，降低性能

## LCA
当一个节点 p 是另一个节点 q 的祖先时，LCA(p, q) 永远是 p 本身。反之亦然，如果 q 是 p 的祖先，那么 LCA(p, q) 就是 q。这是因为 p 和 q 的所有公共祖先中，p 是离它们最近且深度最大的。

## 算法的鲁棒性
算法的鲁棒性 **Robustness** 是指一个算法在面对异常情况、错误输入或不可预期的变化时，仍然能够稳定、正确地运行并给出合理结果的能力。

一个鲁棒性强的算法，就像一个坚固的工具，即使在恶劣条件下也能正常工作。相反，鲁棒性差的算法则可能因为一个小问题就崩溃、给出错误结果或者陷入无限循环。

## 递推、递归、数学归纳法
三者的核心联系
这三者都基于一个共同的逻辑：用已知/更简单的情况来推导出未知/更复杂的情况。

数学归纳法：是一种证明方法，它的思想是“如果基础情况成立，且能从一个情况推导出下一个情况，则所有情况都成立”。

递归（自上而下 二叉树）：是一种编程技巧，它的思想是“为了解决一个问题，先解决一个更小、更简单的同类问题”。它的实现方式是函数调用自身。

递推（自下而上 动态规划）：是一种算法思想，它的思想是“从已知的初始值出发，按照一定的规则，一步一步地推导出下一个值，直到达到目标”。它的实现方式通常是循环。

从这个角度来看，递推和递归非常像，它们都是数学归纳法思想在编程领域的两种实现形式

