## protobuf是什么？
Protobuf（Protocol Buffers）是 Google 开发的一种轻便高效的**数据序列化协议**，用于结构化数据的序列化和反序列化，常被用作 RPC 框架（如 gRPC）的数据交换格式

## 给你全中国的年龄，14亿人按照年龄排序，用什么排序算法
最佳选择：基数排序（或计数排序）
这两种都是非比较排序，利用年龄的 “范围小” 特性，效率远超比较排序：
1. 先看年龄的特点
人的年龄范围非常有限（比如 0-120 岁，最多 121 种可能），这是关键！
2. 计数排序（最简单直接）
思路：
先统计每个年龄有多少人（比如 18 岁有 X 人，19 岁有 Y 人...），然后按年龄从小到大输出对应数量的人。
步骤：
① 准备一个大小为 121 的数组（对应 0-120 岁），初始值全为 0；
② 遍历 14 亿人的年龄，每遇到一个年龄 a，就把数组第 a 位的数字 + 1（统计数量）；
③ 最后从 0 岁开始，按数组中的计数依次输出（比如 0 岁有 300 万人，就输出 300 万次 “0 岁”）。
效率：
时间复杂度 O (n + k)（n 是 14 亿，k 是 121），几乎等于 O (n)，比 O (n log n) 快得多；
空间只需要 121 个整数（约 500 字节），几乎可以忽略。
3. 基数排序（如果需要保留原始数据关联）
如果不仅要排序年龄，还要保留每个人的其他信息（比如姓名、身份证），计数排序不好直接关联，这时用基数排序更合适：

思路：
按年龄的 “位数” 分段排序（先按个位排，再按十位排），利用年龄最大只有 3 位数（0-120）的特点，最多只需要 3 轮排序。
优势：
时间复杂度同样接近 O (n)，且能保留原始数据的关联关系，适合实际业务场景（比如排序后还能知道 “哪些人是 18 岁”）。
总结
单纯排年龄数字：用计数排序，最快且最省空间；
排序年龄并保留个人信息：用基数排序，效率高且能关联原始数据。

这两种算法都利用了 “年龄范围极小” 的特性，避开了比较排序的性能瓶颈，是处理这类数据的最优解